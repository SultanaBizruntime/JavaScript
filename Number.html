<!DOCTYPE html>
<html>
<head>
    <title></title>
	<meta charset="utf-8" />
</head>
<body>
    <script>
    'use strict';
    alert( 0xff ); // 255
    alert(0xFF); // 255 (the same, case doesn't matter)

    let a = 0b11111111; // binary form of 255
    let b = 0o377; // octal form of 255

    alert(a == b); // true, the same number 255 at both sides

    let num = 255;

    alert(num.toString(16));  // ff
    alert(num.toString(2));   // 11111111

        /*
        Can’t we just use the comparison === NaN? Sorry,
        but the answer is no. The value NaN is unique in that it does not equal anything, including itself:
        */

    alert(NaN === NaN); // false

        /* isFinite() : other than number is false.
        */
    alert(isFinite("15")); // true
    alert(isFinite("str")); // false, because a special value: NaN
    alert(isFinite(Infinity)); // false, because a special value: Infinity

        /*
            parseInt and parseFloat
        */
    alert(parseInt('100px')); // 100
    alert(parseFloat('12.5em')); // 12.5

    alert(parseInt('12.3')); // 12, only the integer part is returned
    alert(parseFloat('12.3.4')); // 12.3, the second point stops the reading

        /*
            The second argument of parseInt(str, radix)
        */
    alert(parseInt('0xff', 16)); // 255
    alert(parseInt('ff', 16)); // 255, without 0x also works

    alert(parseInt('2n9c', 36)); // 123456

        /*
            Math.random()
        */
    alert(Math.random()); // 0.1234567894322
    alert(Math.random()); // 0.5435252343232
    alert(Math.random()); // ... (any random numbers)

        /*
            Math.max(a, b, c...) / Math.min(a, b, c...)
        */
    alert(Math.max(3, 5, -10, 0, 1)); // 5
    alert(Math.min(1, 2)); // 1

        /*
            Math.pow(n, power)
        */
    alert(Math.pow(2, 10)); // 2 in power 10 = 1024
    </script>

</body>
</html>
